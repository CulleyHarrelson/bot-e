-- Check if the 'vector' extension exists, and create it if not
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS aws_lambda CASCADE;
--CREATE EXTENSION pg_cron;

-- Drop the 'ask' table and its dependencies if they exist
DROP TABLE IF EXISTS ask CASCADE;

-- Create the 'ask' table with columns and constraints
CREATE TABLE ask (
    ask_id TEXT DEFAULT generateBottyKey() PRIMARY KEY, -- Primary key generated by the function
    prompt TEXT NOT NULL, -- The users prompt - their request for advice
    added_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, -- Timestamp when the record is added
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP, -- Timestamp when the record is updated
    hashtags TEXT[] NULL, -- Array of hashtags (nullable)
    embedding vector(1536) NULL, -- embedding data from llm
    analysis JSONB NULL, -- response to request for meta analysis on question
    moderation JSONB NULL -- response to request for meta analysis on question
);

CREATE INDEX idx_ask_moderation ON ask USING gin(moderation);
CREATE INDEX idx_ask_analysis ON ask USING gin(analysis);
--CREATE INDEX idx_ask_embedding ON ask USING gin(embedding);
CREATE INDEX idx_ask_hashtags ON ask USING gin (hashtags);

-- Create an index on ask.added_at
CREATE INDEX idx_ask_added_at ON ask (added_at);
CREATE INDEX idx_ask_updated_at ON ask (updated_at);

-- Function to set the 'updated_at' column to the current timestamp after an update on 'ask'
CREATE OR REPLACE FUNCTION update_ask_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP; -- Set 'updated_at' column to current timestamp
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop the existing trigger 'update_ask_trigger' if it exists
-- DROP TRIGGER IF EXISTS update_ask_trigger ON ask;

-- Create a new trigger 'update_ask_trigger' after update on 'ask'
CREATE TRIGGER update_ask_trigger
AFTER UPDATE ON ask
FOR EACH ROW
EXECUTE FUNCTION update_ask_timestamp();

DROP TABLE IF EXISTS response CASCADE;

-- Create the 'response' table with columns and constraints
CREATE TABLE response (
    response_id TEXT DEFAULT generateBottyKey() PRIMARY KEY, -- Primary key generated by the function
    ask_id TEXT, -- foreign key
    added_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, -- Primary Key part - Timestamp when the record is added
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, -- Timestamp when the record is added
    message JSONB NOT NULL, -- generated system prompt sent along with user prompt
    response JSONB, -- model response - model type is embedded
    FOREIGN KEY (ask_id) REFERENCES ask(ask_id) ON DELETE CASCADE -- Foreign key constraint
);

CREATE INDEX idx_response_message ON response USING gin(message);
CREATE INDEX idx_response_response ON response USING gin(response);

-- Drop the 'response_queue' table and its dependencies if they exist
DROP TABLE IF EXISTS response_queue CASCADE;

-- Create the 'response_queue' table.  This table is the queue for processing advice requests
CREATE TABLE response_queue (
    ask_id TEXT, -- Foreign key referencing 'ask_id' column in 'ask'
    added_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, -- Timestamp when the record is added
    is_processed BOOLEAN DEFAULT FALSE, -- Flag indicating whether the record is processed or not
    priority INTEGER DEFAULT 0, -- Priority value (default is 0)
    PRIMARY KEY (ask_id, added_at),
    FOREIGN KEY (ask_id) REFERENCES ask(ask_id) ON DELETE CASCADE -- Foreign key constraint
);

-- Create an index on 'response_queue' table to optimize queries involving 'is_processed' and 'priority'
CREATE INDEX idx_ask_queue_priority
ON response_queue (is_processed, priority DESC, added_at ASC);

-- Create an index on 'response_queue' table to optimize queries involving 'ask_id'
CREATE INDEX idx_response_queue_ask
ON response_queue (ask_id);

-- Function to get the next ask from the 'response_queue' table
CREATE OR REPLACE FUNCTION next_queued_ask()
RETURNS SETOF ask AS
$$
DECLARE
  next_ask_id TEXT;
BEGIN
  -- Select the 'ask_id' from 'response_queue' where 'is_processed' is false,
  -- order by 'priority' descending and 'added_at' ascending, and limit to 1 row
  SELECT ask_id INTO next_ask_id 
  FROM response_queue
  WHERE is_processed = FALSE
  ORDER BY priority DESC, added_at ASC
  LIMIT 1;

  -- Return the corresponding row from 'ask' where 'ask_id' matches 'next_ask_id'
  RETURN QUERY SELECT * FROM ask WHERE ask_id = next_ask_id;
END;
$$
LANGUAGE 'plpgsql';

-- Function to insert a record into the 'response_queue' table after an INSERT on 'ask'
CREATE OR REPLACE FUNCTION insert_into_response_queue()
RETURNS TRIGGER AS $$
BEGIN
    -- Insert a new record into the 'response_queue' table with the new 'ask_id'
    INSERT INTO response_queue (ask_id)
    VALUES (NEW.ask_id);
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- Drop the existing trigger 'insert_into_response_queue_trigger' on 'ask' if it exists
--DROP TRIGGER IF EXISTS insert_into_response_queue_trigger ON ask;

-- Create a new trigger 'insert_into_response_queue_trigger' after insert on 'ask'
CREATE TRIGGER insert_into_response_queue_trigger
AFTER INSERT ON ask
FOR EACH ROW
EXECUTE FUNCTION insert_into_response_queue();

